<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo + GitHub Pages搭建个人博客</title>
    <url>/hexo-github-blog/</url>
    <content><![CDATA[<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<p>GitHub Pages 允许每个账户创建一个名为 {username}.github.io 的仓库，另外它还会自动为这个仓库分配一个 github.io 的二级域名。</p>
<span id="more"></span>

<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><ul>
<li><p><a href="https://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</p>
</li>
<li><p><a href="https://git-scm.com/">Git</a></p>
</li>
</ul>
<h3 id="安装脚手架工具-heco-cli"><a href="#安装脚手架工具-heco-cli" class="headerlink" title="安装脚手架工具 heco-cli"></a>安装脚手架工具 <code>heco-cli</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>



<h2 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h2><p>使用 <code>hexo-cli</code> 创建项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;project-name&gt;</span><br></pre></td></tr></table></figure>

<p>目录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml       # hexo配置</span><br><span class="line">├── package.json      # 项目配置</span><br><span class="line">├── scaffolds         # 文章模板</span><br><span class="line">├── source            # 开发目录</span><br><span class="line">|   ├── _drafts       # 草稿</span><br><span class="line">|   └── _posts        # 文章</span><br><span class="line">└── themes            # hexo主题库</span><br></pre></td></tr></table></figure>

<p>生成静态文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>新建文章</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="Themes"><a href="#Themes" class="headerlink" title="Themes"></a>Themes</h2><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 <code>themes</code> 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下：</p>
<h3 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h3><p>如果你在使用 Hexo 5.0 或更新版本，最简单的安装方式是通过 npm：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo-site</span><br><span class="line">$ npm install hexo-theme-next</span><br></pre></td></tr></table></figure>

<p>你也可以直接克隆整个仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo-site</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p>安装完成后，在 Hexo 配置文件中将 <code>theme</code> 设置为 <code>next</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo-site/_config.yml</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><p>在根目录下创建 <code>_config.next.yml</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Installed through npm</span></span><br><span class="line"><span class="built_in">cp</span> node_modules/hexo-theme-next/_config.yml _config.next.yml</span><br><span class="line"><span class="comment"># Installed through Git</span></span><br><span class="line"><span class="built_in">cp</span> themes/next/_config.yml _config.next.yml</span><br></pre></td></tr></table></figure>



<h2 id="Develop"><a href="#Develop" class="headerlink" title="Develop"></a>Develop</h2><p>本文将使用 <a href="https://docs.github.com/zh/actions">GitHub Actions</a> 部署至 GitHub Pages，此方法适用于公开或私人储存库。若你不希望将源文件夹上传到 GitHub，请参阅<a href="#%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2">一键部署</a>。 </p>
<p>在 GitHub 上创建名称为 <code>&lt;username&gt;.github.io</code> 的储存库，若之前已将 Hexo 上传至其他储存库，将该储存库重命名即可</p>
<p>将 Hexo 文件夹中的文件 push 到储存库的默认分支，默认分支通常名为 <code>main</code>，旧一点的储存库可能名为 <code>master</code></p>
<ul>
<li><p>将 <code>main</code> 分支 push 到 GitHub：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push -u origin main</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认情况下 <code>public/</code> 不会被上传(也不该被上传)，确保 <code>.gitignore</code> 文件中包含一行 <code>public/</code>。整体文件夹结构应该与 <a href="https://github.com/hexojs/hexo-starter">范例储存库</a> 大致相似。</p>
</li>
</ul>
<p>使用 <code>node --version</code> 指令检查你电脑上的 Node.js 版本，并记下该版本 (例如：<code>v16.y.z</code>)</p>
<p>在储存库中建立 <code>.github/workflows/pages.yml</code>，并填入以下内容 (将 <code>16</code> 替换为上个步骤中记下的版本)：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .github/workflows/pages.yml</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span> <span class="comment"># default branch</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">pages:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">permissions:</span></span><br><span class="line">      <span class="attr">contents:</span> <span class="string">write</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">16.</span><span class="string">x</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;16&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">NPM</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.OS</span> <span class="string">&#125;&#125;-npm-cache</span></span><br><span class="line">          <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br></pre></td></tr></table></figure>

<p>当部署作业完成后，产生的页面会放在储存库中的 <code>gh-pages</code> 分支</p>
<p>在储存库中前往 <code>Settings &gt; Pages &gt; Source</code>，并将 branch 改为 <code>gh-pages</code>。</p>
<p>前往 <code>https://&lt;你的 GitHub 用户名&gt;.github.io</code> 查看网站。</p>
<h3 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h3><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>配置 <code>_config.yml</code> </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/&lt;username&gt;/&lt;project&gt;</span></span><br><span class="line">  <span class="comment"># example, https://github.com/hexojs/hexojs.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">gh-pages</span></span><br></pre></td></tr></table></figure>

<p>执行部署命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>

<p>浏览 <code>&lt;GitHub 用户名&gt;.github.io</code> 检查你的网站能否运作</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p><a href="https://github.com/edwhpt/edwhpt.github.io">https://github.com/edwhpt/edwhpt.github.io</a></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【React】create-react-app 基础运用</title>
    <url>/react-note-01-cra-usage/</url>
    <content><![CDATA[<p>使用React脚手架工具 <code>create-react-app</code> 搭建项目</p>
<span id="more"></span>


<h2 id="安装脚手架"><a href="#安装脚手架" class="headerlink" title="安装脚手架"></a>安装脚手架</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装脚手架</span></span><br><span class="line">$ sudo npm install create-react-app -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查安装情况</span></span><br><span class="line">$ create-react-app --version</span><br><span class="line"><span class="comment"># output: 5.0.1</span></span><br></pre></td></tr></table></figure>

<h2 id="基于脚手架创建React工程化项目"><a href="#基于脚手架创建React工程化项目" class="headerlink" title="基于脚手架创建React工程化项目"></a>基于脚手架创建React工程化项目</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ create-react-app [project-name]</span><br><span class="line"><span class="comment"># 项目名称要遵循npm包命名规范：使用“数字、小写字母、_“命名</span></span><br></pre></td></tr></table></figure>

<h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── node_modules        # 依赖模块</span><br><span class="line">├── public              # 静态资源</span><br><span class="line">│   ├── favicon.ico     # 浏览器图标</span><br><span class="line">│   └── index.html      # 页面模板</span><br><span class="line">├── src                 # 源代码 「打包的时候一般只针对src目录进行处理」</span><br><span class="line">│   └── index.js        # 入口文件</span><br><span class="line">└── package.json        # 项目配置</span><br></pre></td></tr></table></figure>

<h4 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h4><p><code>./package.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-cra-demo&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;private&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 项目依赖</span></span><br><span class="line">    <span class="attr">&quot;@testing-library/jest-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.16.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@testing-library/react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^13.4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@testing-library/user-event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^13.5.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.2.0&quot;</span><span class="punctuation">,</span> <span class="comment">// React框架的核心</span></span><br><span class="line">    <span class="attr">&quot;react-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.2.0&quot;</span><span class="punctuation">,</span> <span class="comment">// React视图渲染的核心</span></span><br><span class="line">    <span class="attr">&quot;react-scripts&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5.0.1&quot;</span><span class="punctuation">,</span> <span class="comment">// 封装/重写了webpack配置</span></span><br><span class="line">    <span class="attr">&quot;web-vitals&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.1.4&quot;</span> <span class="comment">// 性能检测工具</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 命令脚本（打包命令是基于react-scripts处理）</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts start&quot;</span><span class="punctuation">,</span> <span class="comment">// 开发环境：在本地启动web服务，预览打包内容</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts build&quot;</span><span class="punctuation">,</span> <span class="comment">// 生产环境：打包部署，打包内容输入到build(dist)目录中</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts test&quot;</span><span class="punctuation">,</span> <span class="comment">// 单元测试</span></span><br><span class="line">    <span class="attr">&quot;eject&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts eject&quot;</span> <span class="comment">// 暴露webpack配置规则（修改默认配置）</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 对webpack中ESLint词法检测的相关配置</span></span><br><span class="line"><span class="comment">   * + 词法错误「不符合标准规范」</span></span><br><span class="line"><span class="comment">   * + 符合标准，代码本身不会报错，但是不符合ESLint的检测规范</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="attr">&quot;eslintConfig&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">    <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;react-app&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;react-app/jest&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 基于browserslist规范，设置浏览器的兼容情况</span></span><br><span class="line"><span class="comment">   * 1. postcss-loader + autoprefixer 会给CSS3设置相关的前缀</span></span><br><span class="line"><span class="comment">   * 2. babel-loader 会把ES6编译为ES5</span></span><br><span class="line"><span class="comment">   * ...</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">&quot;browserslist&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;production&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;&gt;0.2%&quot;</span><span class="punctuation">,</span> <span class="comment">// 使用率超过2%的浏览器</span></span><br><span class="line">      <span class="string">&quot;not dead&quot;</span><span class="punctuation">,</span> <span class="comment">//没有死亡的浏览器 =&gt; 不考虑IE</span></span><br><span class="line">      <span class="string">&quot;not op_mini all&quot;</span> <span class="comment">// 不考虑欧朋浏览器</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;development&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;last 1 chrome version&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;last 1 firefox version&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;last 1 safari version&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认不兼容低版本和IE浏览器</span></span><br><span class="line"><span class="comment">     * 配置兼容IE：(IE8以上)</span></span><br><span class="line"><span class="comment">     *   &gt;0.2%</span></span><br><span class="line"><span class="comment">     *   last 2 versions</span></span><br><span class="line"><span class="comment">     *   not ie &lt;= 8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>一个React项目中，默认会安装</p>
<ul>
<li>react：React框架的核心</li>
<li>react-dom：React视图渲染的核心「基于React构建WebApp（HTML页面）」</li>
<li>react-scripts：把 <code>webpack</code> 打包的规则和相关 <code>plugin</code> &#x2F; <code>loader</code> 等都隐藏到了 <code>node_modules</code> 目录下，<code>react-script</code> 就是脚手架对打包命令的封装， 基于它打包，会调用 <code>node_modules</code> 下的 <code>webpack</code> 等进行处理</li>
</ul>
<h4 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h4><p><code>./src/index.js</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom/client&#x27;;</span><br><span class="line"></span><br><span class="line">const root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;));</span><br><span class="line">root.render(&lt;div&gt;Hello, World!&lt;/div&gt;);</span><br></pre></td></tr></table></figure>

<h4 id="页面模板"><a href="#页面模板" class="headerlink" title="页面模板"></a>页面模板</h4><p><code>./public/index.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;%PUBLIC_URL%/favicon.ico&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>React App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p><a href="https://github.com/edwhpt/react-cra-template">https://github.com/edwhpt/react-cra-template</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>create-react-app</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Rollup搭建开发环境</title>
    <url>/rollup-build/</url>
    <content><![CDATA[<p><a href="https://www.rollupjs.com/">Rollup</a> 是一个 JavaScript 模块打包工具，可以将多个小的代码片段编译为完整的库和应用。与传统的 CommonJS 和 AMD 这一类非标准化的解决方案不同，Rollup 使用的是 ES6 版本 Javascript 中的模块标准。新的 ES 模块可以让你自由、无缝地按需使用你最喜爱的库中那些有用的单个函数。这一特性在未来将随处可用，但 Rollup 让你现在就可以，想用就用。</p>
<span id="more"></span>


<h3 id="初始化环境"><a href="#初始化环境" class="headerlink" title="初始化环境"></a>初始化环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm init -y</span><br></pre></td></tr></table></figure>

<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><ul>
<li>rollup：打包工具，相对于webpack打包体积更小</li>
<li>rollup-plugin-babel：rollup环境的babel插件，负责编译JS高级语法</li>
<li>@babel&#x2F;core：babel核心模块</li>
<li>@babel&#x2F;preset-env：babel预设插件，把高级语法转换为低级语法，比如let&#x2F;const转换为var，箭头函数、类的转换</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install rollup rollup-plugin-babel @babel/core @babel/preset-env --save-dev</span><br></pre></td></tr></table></figure>

<h3 id="创建打包入口文件-src-x2F-index-js"><a href="#创建打包入口文件-src-x2F-index-js" class="headerlink" title="创建打包入口文件 src&#x2F;index.js"></a>创建打包入口文件 src&#x2F;index.js</h3><h3 id="在根目录创建rollup配置文件，默认名字为-rollup-config-js"><a href="#在根目录创建rollup配置文件，默认名字为-rollup-config-js" class="headerlink" title="在根目录创建rollup配置文件，默认名字为 rollup.config.js"></a>在根目录创建rollup配置文件，默认名字为 rollup.config.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-babel&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rollup默认可以导出一个对象，作为打包的配置文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">input</span>: <span class="string">&#x27;./src/index.js&#x27;</span>, <span class="comment">// 入口文件</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">file</span>: <span class="string">&#x27;./dist/vue.js&#x27;</span>, <span class="comment">// 出口文件</span></span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Vue&#x27;</span>, <span class="comment">// 全局添加Vue属性，global.Vue</span></span><br><span class="line">        <span class="attr">format</span>: <span class="string">&#x27;umd&#x27;</span>, <span class="comment">// esm es6模块  commonjs模块  iife自执行函数  umd（支持commonjs、amd）</span></span><br><span class="line">        <span class="attr">sourcemap</span>: <span class="literal">true</span> <span class="comment">// 希望可以调试源代码</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 配置一些插件</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">      <span class="comment">// 所有插件都是函数，直接执行</span></span><br><span class="line">      <span class="title function_">babel</span>(&#123;</span><br><span class="line">        <span class="attr">exclude</span>: <span class="string">&#x27;node_modules/**&#x27;</span> <span class="comment">// 排除node_modules所有文件</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建babel配置文件-babelrc，打包时使用babel会默认采用配置文件中的配置属性"><a href="#创建babel配置文件-babelrc，打包时使用babel会默认采用配置文件中的配置属性" class="headerlink" title="创建babel配置文件 .babelrc，打包时使用babel会默认采用配置文件中的配置属性"></a>创建babel配置文件 .babelrc，打包时使用babel会默认采用配置文件中的配置属性</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;@babel/preset-env&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="在package-json中配置rollup命令脚本"><a href="#在package-json中配置rollup命令脚本" class="headerlink" title="在package.json中配置rollup命令脚本"></a>在package.json中配置rollup命令脚本</h3><ul>
<li>rollup -c（rollup –config）打包时使用配置文件（rollup.config.js）里面的配置属性</li>
<li>rollup -w (rollup –watch）监控文件变化，文件发生变化时重新打包</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rollup -cw&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>rollup</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue2源码】数据响应式（observer）</title>
    <url>/vue2-source-01-observer/</url>
    <content><![CDATA[<p>响应式基本原理就是，在 Vue 的构造函数中，对 options 的 data 进行处理。即在初始化vue实例的时候，对data、props等对象的每一个属性都通过 Object.defineProperty 定义一次，在数据被set的时候，做一些操作，改变相应的视图。</p>
<span id="more"></span>

<h2 id="数据观测"><a href="#数据观测" class="headerlink" title="数据观测"></a>数据观测</h2><p>基于 Object.defineProperty 来实现对数组和对象的劫持</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; newArrayProto &#125; <span class="keyword">from</span> <span class="string">&#x27;./array&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(data)) &#123;</span><br><span class="line">      <span class="comment">// 这里我们可以重写可以修改数组本身的方法 7个方法</span></span><br><span class="line">      <span class="comment">// 切片编程：需要保留数组原有的特性，并且可以重写部分方法</span></span><br><span class="line">      data.<span class="property">__proto__</span> = newArrayProto</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">observeArray</span>(data) <span class="comment">// 如果数组中放的是对象 可以监控到对象的变化</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">walk</span>(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环对象&quot;重新定义属性&quot;,对属性依次劫持，性能差</span></span><br><span class="line">  <span class="title function_">walk</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> <span class="title function_">defineReactive</span>(data, key, data[key]))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 观测数组</span></span><br><span class="line">  <span class="title function_">observeArray</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    data.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title function_">observe</span>(item))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">data,key,value</span>)&#123;</span><br><span class="line">  <span class="title function_">observe</span>(value)  <span class="comment">// 深度属性劫持，对所有的对象都进行属性劫持</span></span><br><span class="line"></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data,key,&#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newValue</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(newValue == value) <span class="keyword">return</span></span><br><span class="line">      <span class="title function_">observe</span>(newValue) <span class="comment">// 修改属性之后重新观测，目的：新值为对象或数组的话，可以劫持其数据</span></span><br><span class="line">      value = newValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// 只对对象进行劫持</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> data !== <span class="string">&#x27;object&#x27;</span> || data == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Observer</span>(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重写数组7个变异方法"><a href="#重写数组7个变异方法" class="headerlink" title="重写数组7个变异方法"></a>重写数组7个变异方法</h2><p>7个方法是指：push、pop、shift、unshift、sort、reverse、splice。（这七个都是会改变原数组的） 实现思路：面向切片编程！！！</p>
<blockquote>
<p>不是直接粗暴重写 Array.prototype 上的方法，而是通过原型链继承与函数劫持进行的移花接木。</p>
</blockquote>
<p>利用 Object.create(Array.prototype) 生成一个新的对象 newArrayProto，该对象的 <strong>proto</strong> 指向 Array.prototype，然后将我们数组的 <strong>proto</strong> 指向拥有重写方法的新对象 newArrayProto，这样就保证了 newArrayProto 和 Array.prototype 都在数组的原型链上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.<span class="property">__proto__</span> === newArrayProto；newArrayProto.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>

<p>然后在重写方法的内部使用 Array.prototype[method].call 调用原来的方法，并对新增数据进行劫持观测。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oldArrayProto = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// 获取数组的原型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> newArrayProto = <span class="title class_">Object</span>.<span class="title function_">create</span>(oldArrayProto)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到所有的变异方法</span></span><br><span class="line"><span class="keyword">let</span> methods = [<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;reverse&#x27;</span>, <span class="string">&#x27;sort&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>]</span><br><span class="line"></span><br><span class="line">methods.<span class="title function_">forEach</span>(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里重写了数组的方法</span></span><br><span class="line">  newArrayProto[method] = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// args reset参数收集，args为真正数组，arguments为伪数组</span></span><br><span class="line">    <span class="comment">// 内部调用原来的方法，函数的劫持，切片编程</span></span><br><span class="line">    <span class="keyword">const</span> result = oldArrayProto[method].<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args) </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们需要对新增的数据再次进行劫持</span></span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">let</span> ob = <span class="variable language_">this</span>.<span class="property">__ob__</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>: <span class="comment">// arr.unshift(1,2,3)</span></span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>: <span class="comment">// arr.splice(0,1,&#123;a:1&#125;,&#123;a:1&#125;)</span></span><br><span class="line">        inserted = args.<span class="title function_">slice</span>(<span class="number">2</span>)</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inserted) &#123;</span><br><span class="line">      <span class="comment">// 对新增的内容再次进行观测</span></span><br><span class="line">      ob.<span class="title function_">observeArray</span>(inserted)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="增加-ob-属性"><a href="#增加-ob-属性" class="headerlink" title="增加 __ob__ 属性"></a>增加 <code>__ob__</code> 属性</h2><p>这是一个恶心又巧妙的属性，我们在 Observer 类内部，把 this 实例添加到了响应式数据上。相当于给所有响应式数据增加了一个标识，并且可以在响应式数据上获取 Observer 实例上的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// 给数据加了一个标识,如果数据上有__ob__ 则说明这个属性被观测过了</span></span><br><span class="line">    <span class="comment">// data.__ob__ = this </span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;__ob__&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="variable language_">this</span>,</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="comment">// 将__ob__ 变成不可枚举 （循环的时候无法获取到，防止栈溢出）</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(data)) &#123;</span><br><span class="line">      <span class="comment">// 这里我们可以重写可以修改数组本身的方法 7个方法</span></span><br><span class="line">      <span class="comment">// 切片编程：需要保留数组原有的特性，并且可以重写部分方法</span></span><br><span class="line">      data.<span class="property">__proto__</span> = newArrayProto</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">observeArray</span>(data) <span class="comment">// 如果数组中放的是对象 可以监控到对象的变化</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">walk</span>(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>__ob__</code> 有两大用处：</strong></p>
<ol>
<li>如果一个对象被劫持过了，那就不需要再被劫持了，要判断一个对象是否被劫持过，可以通过 <code>__ob__</code> 来判断</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据观测</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// 只对对象进行劫持</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data !== <span class="string">&#x27;object&#x27;</span> || data == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果一个对象被劫持过了，那就不需要再被劫持了 </span></span><br><span class="line">  <span class="comment">// (要判断一个对象是否被劫持过，可以在对象上增添一个实例，用实例的原型链来判断是否被劫持过)</span></span><br><span class="line">  <span class="keyword">if</span> (data.<span class="property">__ob__</span> <span class="keyword">instanceof</span> <span class="title class_">Observer</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> data.<span class="property">__ob__</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Observer</span>(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>我们重写了数组的7个变异方法，其中 push、unshift、splice 这三个方法会给数组新增成员。此时需要对新增的成员再次进行观测，可以通过 <code>__ob__</code> 调用 Observer 实例上的 observeArray 方法</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote>
<p>Vue 2 是基于 Object.defineProperty 实现的响应式系统 （这个方法是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因）<br>Vue3 是基于 Proxy&#x2F;Reflect 来实现的</p>
</blockquote>
<ol>
<li>Object.defineProperty()  无法检测对象和数组新增的属性和数组长度变化</li>
<li>Vue 无法检测通过索引直接修改数组元素的操作，这不是 Object.defineProperty 的原因，而是作者尤老师认为性能消耗与带来的用户体验不成正比。因为数组长度可能很大，对数组进行响应式检测会带来很大的性能消耗</li>
</ol>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p><a href="https://github.com/edwhpt/vue2-stage">https://github.com/edwhpt/vue2-stage</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue2源码】模板编译（complier）</title>
    <url>/vue2-source-02-complier/</url>
    <content><![CDATA[<p>将 <code>data</code> 数据解析到 <code>el</code> 元素上，需要将 <code>template</code> 语法转换成 <code>render</code> 函数</p>
<span id="more"></span>

<blockquote>
<p>实现方式：</p>
<ol>
<li><p>模板引擎，性能差，需要正则匹配替换；Vue1.0的时候没有引入虚拟DOM的概念</p>
</li>
<li><p>采用虚拟DOM，数据变化后比较虚拟DOM的差异，最后更新需要更新的地方</p>
<p>核心就是将template模板变成JS语法，通过JS语法生成虚拟DOM</p>
</li>
</ol>
</blockquote>
<h2 id="初始化-mount-方法"><a href="#初始化-mount-方法" class="headerlink" title="初始化 $mount 方法"></a>初始化 <code>$mount</code> 方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span>(<span class="params">el</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="variable language_">this</span></span><br><span class="line">  el = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(el)</span><br><span class="line">  <span class="keyword">let</span> ops = vm.<span class="property">$options</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!ops.<span class="property">render</span>) &#123; <span class="comment">// 先找render函数</span></span><br><span class="line">    <span class="keyword">let</span> template <span class="comment">// 没有render看一下是否有template，没有template就采用el外部元素</span></span><br><span class="line">    <span class="keyword">if</span> (!ops.<span class="property">template</span> &amp;&amp; el) &#123; <span class="comment">// 没写template，但是写了el</span></span><br><span class="line">      <span class="keyword">if</span> (!ops.<span class="property">template</span> &amp;&amp; el) &#123;</span><br><span class="line">        template = el.<span class="property">outerHTML</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (el) &#123;</span><br><span class="line">          template = ops.<span class="property">template</span> <span class="comment">// 如果有el，则采用模板的内容</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">// 这里需要对模板进行编译</span></span><br><span class="line">      <span class="keyword">const</span> render = <span class="title function_">complieToFunction</span>(template)</span><br><span class="line">      ops.<span class="property">render</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ops.<span class="property">render</span> <span class="comment">// 最终就可以获取render方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>script 标签引用的vue.global.js 这个编译过程是在浏览器运行的</p>
<p>runtime 是不包含模板编译的，整个编译过程是打包的时候通过loader来转义.vue文件的，用runtime时不能使用template</p>
</blockquote>
<h2 id="通过-complieToFunction-方法对模版进行编译处理"><a href="#通过-complieToFunction-方法对模版进行编译处理" class="headerlink" title="通过 complieToFunction 方法对模版进行编译处理"></a>通过 <code>complieToFunction</code> 方法对模版进行编译处理</h2><ul>
<li>将 <code>template</code> 转化成 <code>AST</code> 语法树</li>
<li>生成 <code>render</code> 方法（render方法返回的结果就是 <code>虚拟DOM</code>）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">compileToFunction</span>(<span class="params">template</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.将template 转化成ast语法树</span></span><br><span class="line">    <span class="keyword">let</span> ast = <span class="title function_">parseHTML</span>(template)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.生成render方法 （render方法执行后返回的结果就是 虚拟DOM）</span></span><br><span class="line">    <span class="keyword">let</span> code = <span class="title function_">codegen</span>(ast)</span><br><span class="line">    code = <span class="string">`with(this)&#123;return <span class="subst">$&#123;code&#125;</span>&#125;`</span></span><br><span class="line">    <span class="keyword">let</span> render = <span class="keyword">new</span> <span class="title class_">Function</span>(code)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> render</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h3><p>在Vue的 <code>$mount</code> 过程中，编译过程首先就是调用 <code>parseHTML</code> 方法，解析 <code>template</code> 模版，生成 <code>AST</code> 语法树 在这个过程，我们会用到正则表达式对字符串解析，匹配开始标签、文本内容和闭合标签等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ncname = <span class="string">`[a-zA-Z_][\\-\\.0-9_a-zA-Z]*`</span></span><br><span class="line"><span class="keyword">const</span> qnameCapture = <span class="string">`((?:<span class="subst">$&#123;ncname&#125;</span>\\:)?<span class="subst">$&#123;ncname&#125;</span>)`</span></span><br><span class="line"><span class="keyword">const</span> startTagOpen = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`^&lt;<span class="subst">$&#123;qnameCapture&#125;</span>`</span>) <span class="comment">// 匹配到的分组是一个 标签名 &lt;div 匹配到的是开始标签的名字</span></span><br><span class="line"><span class="keyword">const</span> endTag = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`^&lt;\\/<span class="subst">$&#123;qnameCapture&#125;</span>[^&gt;]*&gt;`</span>) <span class="comment">// 匹配的是 &lt;/xxx&gt; 最终匹配到的分组是结束标签的名字</span></span><br><span class="line"><span class="keyword">const</span> attribute = <span class="regexp">/^\s*([^\s&quot;&#x27;&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\s&quot;&#x27;=&lt;&gt;`]+)))?/</span> <span class="comment">// 匹配属性，第一个分组是属性的key，value可能是分组3/分组4/分组5</span></span><br><span class="line"><span class="keyword">const</span> startTagClose = <span class="regexp">/^\s*(\/?)&gt;/</span> <span class="comment">// &lt;div&gt;  &lt;br/&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>while</code> 遍历 <code>HTML</code> 字符串，利用正则去匹配开始标签、文本内容和闭合标签，然后执行 <code>advance</code> 方法将匹配到的内容在原HTML字符串中剔除，直到 <code>HTML</code> 字符串为空，结束循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parseHTML</span>(<span class="params">html</span>) &#123;</span><br><span class="line">  <span class="comment">// 循环html字符串，直到其为空停止</span></span><br><span class="line">  <span class="keyword">while</span> (html) &#123;</span><br><span class="line">    <span class="comment">// 如果textEnd = 0 说明是一个开始标签或者结束标签</span></span><br><span class="line">    <span class="comment">// 如果textEnd &gt; 0 说明就是文本的结束位置</span></span><br><span class="line">    <span class="keyword">let</span> textEnd = html.<span class="title function_">indexOf</span>(<span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (textEnd == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 开始标签的解析結果，包括 标签名 和 属性</span></span><br><span class="line">      <span class="keyword">const</span> startTagMatch = <span class="title function_">parseStartTag</span>()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (startTagMatch) &#123;</span><br><span class="line">        <span class="title function_">start</span>(startTagMatch.<span class="property">tagName</span>, startTagMatch.<span class="property">attrs</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 匹配结束标签</span></span><br><span class="line">      <span class="keyword">let</span> endTagMatch = html.<span class="title function_">match</span>(endTag)</span><br><span class="line">      <span class="keyword">if</span> (endTagMatch) &#123;</span><br><span class="line">        <span class="title function_">advance</span>(endTagMatch[<span class="number">0</span>].<span class="property">length</span>)</span><br><span class="line">        <span class="title function_">end</span>(endTagMatch[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (textEnd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> text = html.<span class="title function_">substring</span>(<span class="number">0</span>, textEnd) <span class="comment">// 截取文本内容</span></span><br><span class="line">      <span class="keyword">if</span> (text) &#123;</span><br><span class="line">        <span class="title function_">chars</span>(text)</span><br><span class="line">        <span class="title function_">advance</span>(text.<span class="property">length</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析开始标签</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">parseStartTag</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> start = html.<span class="title function_">match</span>(startTagOpen)</span><br><span class="line">    <span class="keyword">if</span> (start) &#123;</span><br><span class="line">      <span class="keyword">const</span> match = &#123;</span><br><span class="line">        <span class="attr">tagName</span>: start[<span class="number">1</span>], <span class="comment">// 标签名</span></span><br><span class="line">        <span class="attr">attrs</span>: [],</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">advance</span>(start[<span class="number">0</span>].<span class="property">length</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> attr, end</span><br><span class="line">      <span class="comment">// 如果不是开始标签的结束 就一直匹配下去</span></span><br><span class="line">      <span class="keyword">while</span> (!(end = html.<span class="title function_">match</span>(startTagClose)) &amp;&amp; (attr = html.<span class="title function_">match</span>(attribute))) &#123;</span><br><span class="line">        <span class="title function_">advance</span>(attr[<span class="number">0</span>].<span class="property">length</span>)</span><br><span class="line">        match.<span class="property">attrs</span>.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: attr[<span class="number">1</span>], <span class="attr">value</span>: attr[<span class="number">3</span>] || attr[<span class="number">4</span>] || attr[<span class="number">5</span>] || <span class="literal">true</span> &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果不是开始标签的结束</span></span><br><span class="line">      <span class="keyword">if</span> (end) &#123;</span><br><span class="line">        <span class="title function_">advance</span>(end[<span class="number">0</span>].<span class="property">length</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> match</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 剔除 template 已匹配的内容</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">advance</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    html = html.<span class="title function_">substring</span>(n)</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// todo</span></span><br><span class="line">  <span class="comment">// 处理开始标签，利用栈型结构来构造一颗树</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">start</span>(<span class="params">tag, attrs</span>) &#123;&#125;</span><br><span class="line">	<span class="comment">// 处理文本</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">chars</span>(<span class="params">text</span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// 处理结束标签</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">end</span>(<span class="params">tag</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> <a href="https://www.npmjs.com/package/htmlparser2">htmlparse2</a> 实现了同样的效果，这里通过手动实现理解相关原理</p>
</blockquote>
<p>当我们使用正则匹配到开始标签、文本内容和闭合标签时，分别执行 <code>start</code>、<code>chars</code>、<code>end</code>方法去处理，利用 <code>stack</code> 栈型数据结构，最终构造一颗 <code>AST</code> 语法树，即 <code>root</code></p>
<ol>
<li>匹配到开始标签时，就创建一个 <code>AST</code> 元素，判断如果有 <code>currentParent</code>，会把当前 <code>AST</code> 元素 push 到 <code>currentParent.chilldren</code> 中，同时把 ast元素的 parent 指向 currentParent，ast元素入栈并更新 currentParent</li>
<li>匹配到文本时，就给 currentParent.children push一个文本 ast元素</li>
<li>匹配到结束标签时，就弹出栈中最后一个 <code>AST</code> 元素，更新 <code>currentParent</code></li>
</ol>
<p>currentParent：指向的是栈中的最后一个 <code>AST</code> 节点</p>
<blockquote>
<p>注意：栈中的当前ast节点永远是下一个AST节点的父节点</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parseHTML</span>(<span class="params">html</span>) &#123;<span class="keyword">const</span> <span class="variable constant_">ELEMENT_TYPE</span> = <span class="number">1</span> <span class="comment">// 元素类型</span></span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">TEXT_TYPE</span> = <span class="number">3</span> <span class="comment">// 文本类型</span></span><br><span class="line">  <span class="keyword">const</span> stack = [] <span class="comment">// 用于存放元素的栈</span></span><br><span class="line">  <span class="keyword">let</span> currentParent <span class="comment">// 指向的是栈中的最后一个</span></span><br><span class="line">  <span class="keyword">let</span> root</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// while ...</span></span><br><span class="line">  <span class="comment">// parseStartTag ...</span></span><br><span class="line">  <span class="comment">// advance ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最终需要转化成一颗抽象语法树</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">createASTElement</span>(<span class="params">tag, attrs</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      tag, <span class="comment">// 标签名</span></span><br><span class="line">      <span class="attr">type</span>: <span class="variable constant_">ELEMENT_TYPE</span>, <span class="comment">// 类型</span></span><br><span class="line">      attrs, <span class="comment">// 属性</span></span><br><span class="line">      <span class="attr">parent</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">children</span>: [],</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理开始标签，利用栈型结构 来构造一颗树</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">start</span>(<span class="params">tag, attrs</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="title function_">createASTElement</span>(tag, attrs) <span class="comment">// 创造一个 ast节点</span></span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">      root = node <span class="comment">// 如果root为空，则当前是树的根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentParent) &#123;</span><br><span class="line">      node.<span class="property">parent</span> = currentParent <span class="comment">// 只赋予了parent属性</span></span><br><span class="line">      currentParent.<span class="property">children</span>.<span class="title function_">push</span>(node) <span class="comment">// 还需要让父亲记住自己</span></span><br><span class="line">    &#125;</span><br><span class="line">    stack.<span class="title function_">push</span>(node)</span><br><span class="line">    currentParent = node <span class="comment">// currentParent为栈中的最后一个</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理文本</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">chars</span>(<span class="params">text</span>) &#123;</span><br><span class="line">    text = text.<span class="title function_">replace</span>(<span class="regexp">/\s/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment">// 文本直接放到当前指向的节点中</span></span><br><span class="line">    <span class="keyword">if</span> (text) &#123;</span><br><span class="line">      currentParent.<span class="property">children</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="variable constant_">TEXT_TYPE</span>,</span><br><span class="line">        text,</span><br><span class="line">        <span class="attr">parent</span>: currentParent,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理结束标签</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">end</span>(<span class="params">tag</span>) &#123;</span><br><span class="line">    stack.<span class="title function_">pop</span>() <span class="comment">// 弹出栈中最后一个ast节点</span></span><br><span class="line">    currentParent = stack[stack.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以利用AST的可视化工具网站 - <a href="https://link.juejin.cn/?target=https://astexplorer.net/">AST Exploer</a> ，使用各种parse对代码进行AST转换</p>
</blockquote>
<h3 id="codegen"><a href="#codegen" class="headerlink" title="codegen"></a>codegen</h3><p>编译的最后一步就是把优化后的 AST树转换成可执行的 render代码。此过程包含两部分，第一部分是使用 codegen方法生成 render代码字符串，第二部分是利用模板引擎转换成可执行的 render代码 render方法代码字符串格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`_c(&#x27;div&#x27;, &#123;id:&quot;app&quot;,style:&#123;&quot;color&quot;:&quot; red&quot;,&quot;background&quot;:&quot; white&quot;&#125;&#125;,_v(&quot;hello,&quot;+_s(name)))`</span><br></pre></td></tr></table></figure>

<p>我们会在Vue原型上扩展这些方法</p>
<blockquote>
<p>_c: 执行 createElement创建虚拟DOM标签；</p>
<p>_v: 执行 createTextVNode创建虚拟DOM文本；</p>
<p>_s: 处理变量；</p>
</blockquote>
<p>实现一个简单的 <code>codegen</code> 方法，深度遍历 <code>AST</code> 树去生成 <code>render</code> 代码字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">codegen</span>(<span class="params">ast</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> children = <span class="title function_">genChildren</span>(ast.<span class="property">children</span>)</span><br><span class="line">  <span class="keyword">let</span> code = <span class="string">`_c(&#x27;<span class="subst">$&#123;ast.tag&#125;</span>&#x27;,<span class="subst">$&#123;ast.attrs.length &gt; <span class="number">0</span> ? genProps(ast.attrs) : <span class="string">&#x27;null&#x27;</span>&#125;</span><span class="subst">$&#123;ast.children.length ? <span class="string">`,<span class="subst">$&#123;children&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>)`</span></span><br><span class="line">  <span class="keyword">return</span> code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据ast语法树的 children对象 生成相对应的 children字符串</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">genChildren</span>(<span class="params">children</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> children.<span class="title function_">map</span>(<span class="function"><span class="params">child</span> =&gt;</span> <span class="title function_">gen</span>(child)).<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultTagRE = <span class="regexp">/\&#123;\&#123;((?:.|\r?\n)+?)\&#125;\&#125;/g</span> <span class="comment">// 匹配到的内容就是我们表达式的变量，例如 &#123;&#123; name &#125;&#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gen</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">type</span> === <span class="number">1</span>) &#123;  <span class="comment">// 元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">codegen</span>(node)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 文本</span></span><br><span class="line">    <span class="keyword">let</span> text = node.<span class="property">text</span></span><br><span class="line">    <span class="keyword">if</span> (!defaultTagRE.<span class="title function_">test</span>(text)) &#123;</span><br><span class="line">      <span class="comment">// _v(&#x27;hello&#x27;)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">`_v(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(text)&#125;</span>)`</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//_v( _s(name) + &#x27;hello&#x27; + _s(age))</span></span><br><span class="line">      ... 拼接 _s</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`_v(<span class="subst">$&#123;tokens.join(<span class="string">&#x27;+&#x27;</span>)&#125;</span>)`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据ast语法树的 attrs属性对象 生成相对应的属性字符串</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">genProps</span>(<span class="params">attrs</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; attrs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> attr = attrs[i]</span><br><span class="line">    str += <span class="string">`<span class="subst">$&#123;attr.name&#125;</span>:<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(attr.value)&#125;</span>,`</span> <span class="comment">// id:&#x27;app&#x27;,class:&#x27;app-inner&#x27;,</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&#123;<span class="subst">$&#123;str.slice(<span class="number">0</span>, -<span class="number">1</span>)&#125;</span>&#125;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板引擎的实现原理就是 <code>with</code> + <code>new Function()</code>，转换成可执行的函数，最终赋值给<code>vm.options.render</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> code = <span class="title function_">codegen</span>(ast)</span><br><span class="line">code = <span class="string">`with(this)&#123;return <span class="subst">$&#123;code&#125;</span>&#125;`</span></span><br><span class="line"><span class="keyword">let</span> render = <span class="keyword">new</span> <span class="title class_">Function</span>(code) </span><br></pre></td></tr></table></figure>

<p>尤雨溪老师解读：<a href="https://www.zhihu.com/question/49929356/answer/118534768">如何看待Vue.js 2.0 的模板编译使用了<code>with(this)</code>的语法?</a></p>
<blockquote>
<p>为啥呢，因为没有什么太明显的坏处（经测试性能影响几乎可以忽略），但是 with 的作用域和模板的作用域正好契合，可以极大地简化模板编译过程。Vue 1.x 使用的正则替换 identifier path 是一个本质上 unsound 的方案，不能涵盖所有的 edge case；而走正经的 parse 到 AST 的路线会使得编译器代码量爆炸。虽然 Vue 2 的编译器是可以分离的，但凡是可能跑在浏览器里的部分，还是要考虑到尺寸问题。用 with 代码量可以很少，而且把作用域的处理交给 js 引擎来做也更可靠。</p>
<p>用 with 的主要副作用是生成的代码不能在 strict mode &#x2F; ES module 中运行，但直接在浏览器里编译的时候因为用了 new Function()，等同于 eval，不受这一点影响。</p>
<p>当然，最理想的情况还是可以把 with 去掉，所以在使用预编译的时候（vue-loader 或 vueify），会自动把第一遍编译生成的代码进行一次额外处理，用完整的 AST 分析来处理作用域，把 with 拿掉，顺便支持模板中的 ES2015 语法。也就是说如果用 webpack + vue 的时候，最终生成的代码是没有 with 的。</p>
</blockquote>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p><a href="https://github.com/edwhpt/vue2-stage">https://github.com/edwhpt/vue2-stage</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue2源码】模版渲染（render）</title>
    <url>/vue2-source-03-render/</url>
    <content><![CDATA[<p><code>render</code> 函数会产生 <code>虚拟DOM</code>（使用响应式数据），然后根据生成的 <code>虚拟DOM</code> 创造 <code>真实DOM</code></p>
<span id="more"></span>

<p>Vue的核心流程：</p>
<ol>
<li>创造了响应式数据</li>
<li>将模板转换成ast语法树</li>
<li>将 <code>AST</code> 语法树转换成了 <code>render</code> 函数</li>
<li>后续每次数据更新可以只执行 <code>render</code> 函数（无需再次执行 <code>AST</code> 转化的过程）</li>
</ol>
<h3 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a>mountComponent</h3><p>通过 <code>mountComponent</code> 方法实现组件的挂载</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span></span><br><span class="line">    el = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(el)</span><br><span class="line">		<span class="comment">// 获取render ...</span></span><br><span class="line">    <span class="title function_">mountComponent</span>(vm, el) <span class="comment">// 挂载组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用 <code>render</code> 方法，创建 <code>虚拟DOM</code></li>
<li>调用 <code>update</code> 方法，根据 <code>虚拟DOM</code> 产生 <code>真实DOM</code> ，将 <code>真实DOM</code> 插入到 <code>el</code> 元素中</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mountComponent</span>(<span class="params">vm, el</span>) &#123;</span><br><span class="line">  vm.<span class="property">$el</span> = el <span class="comment">// 把el挂载到Vue实例上，这里的el是通过querySelector处理过的 (#app)</span></span><br><span class="line">  <span class="keyword">const</span> vnode = vm.<span class="title function_">_render</span>() <span class="comment">// vm.$options.render() =&gt; 虚拟DOM</span></span><br><span class="line">  vm.<span class="title function_">_update</span>(vnode) <span class="comment">// 根据虚拟DOM产生真实DOM，将真实DOM插入到el元素中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展生命周期方法，在Vue原型上添加 <code>render</code>和<code>update</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_init</span>(options) <span class="comment">// options就是用户的选项</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">initMixin</span>(<span class="title class_">Vue</span>)</span><br><span class="line"><span class="title function_">initLifeCycle</span>(<span class="title class_">Vue</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Vue</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initLifeCycle</span>(<span class="params">Vue</span>) &#123;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">  	<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_update</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>在Vue原型上扩展 <code>_render</code> 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 当渲染的时候会去实例中取值，我们就可以将属性和视图绑定在一起</span></span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span></span><br><span class="line">    vm.<span class="property">$options</span>.<span class="property">render</span>.<span class="title function_">call</span>(vm) <span class="comment">// 通过AST语法转义后生成的render方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在之前的 Vue $mount过程中，我们已通过 compileToFunction方法将模版template 编译成 render方法，其返回一个 虚拟DOM。template转化成render函数的结果如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: lightgreen;background: black;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello, &#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render</span></span><br><span class="line">ƒ <span class="title function_">anonymous</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title function_">with</span>(<span class="params"><span class="variable language_">this</span></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">_c</span>(<span class="string">&#x27;div&#x27;</span>, &#123;<span class="attr">id</span>:<span class="string">&quot;app&quot;</span>,<span class="attr">style</span>:&#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot; lightgreen&quot;</span>,<span class="string">&quot;background&quot;</span>:<span class="string">&quot; black&quot;</span>&#125;&#125;,</span><br><span class="line">      <span class="title function_">_c</span>(<span class="string">&#x27;h1&#x27;</span>,<span class="literal">null</span>,<span class="title function_">_v</span>(<span class="string">&quot;hello,&quot;</span>+<span class="title function_">_s</span>(name))),</span><br><span class="line">      <span class="title function_">_c</span>(<span class="string">&#x27;span&#x27;</span>, <span class="literal">null</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>render 内部使用了 <code>_c</code>、<code>_v</code> 、<code>_s</code> 方法，需要在Vue原型扩展这些方法</p>
<ul>
<li>_c 创建虚拟DOM标签</li>
<li>_v 创建虚拟DOM文本</li>
<li>_s 处理变量</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _c(&quot;div&quot;, &#123;&#125;, ...children)</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_c</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createElementVNode</span>(<span class="variable language_">this</span>, ...<span class="variable language_">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// _v(text)</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_v</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createTextVNode</span>(<span class="variable language_">this</span>, ...<span class="variable language_">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_s</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="vdom"><a href="#vdom" class="headerlink" title="vdom"></a>vdom</h4><p>处理标签和文本，返回 <code>VNode</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// h()  _c() 创建虚拟DOM标签</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createElementVNode</span>(<span class="params">vm, tag, data = &#123;&#125;, ...children</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">        data = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> key = data.<span class="property">key</span></span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">        <span class="keyword">delete</span> data.<span class="property">key</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">vnode</span>(vm, tag, key, data, children)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// _v() 创建虚拟DOM文本</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createTextVNode</span>(<span class="params">vm, text</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">vnode</span>(vm, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">vnode</span>(<span class="params">vm, tag, key, data, children, text</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; vm, tag, key, data, children, text &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>AST和VNode的区别<br>AST：是语法层面的转化，描述的是语法本身（可以描述JS、CSS …）<br>虚拟DOM：是描述的DOM元素，可以增加一些自定义属性（描述DOM的）</p>
</blockquote>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p><code>update</code> 内部通过调用 <code>patch</code> 方法，将 <code>render</code> 返回的 <code>VNode</code> 转成 <code>真实DOM</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_update</span> = <span class="keyword">function</span> (<span class="params">vnode</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> el = vm.<span class="property">$el</span></span><br><span class="line">  vm.<span class="property">$el</span> = <span class="title function_">patch</span>(el, vnode) <span class="comment">// 完成渲染，返回更新后的DOM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><p><code>patch</code> 既有初始化元素的功能 ，又有更新元素的逻辑；我们先不管更新的部分</p>
<p>首次渲染流程：</p>
<ul>
<li>通过 <code>createElm</code> 方法递归创建 <code>DOM</code> 树</li>
<li>在页面插入新创建的 <code>DOM</code> 树</li>
<li>删除页面上原有的 <code>DOM</code> 节点</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patch</span>(<span class="params">oldVNode, vnode</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> isRealElement = oldVNode.<span class="property">nodeType</span></span><br><span class="line">    <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">        <span class="comment">// 首次渲染流程</span></span><br><span class="line">        <span class="keyword">const</span> elm = oldVNode <span class="comment">// 获取真实DOM元素</span></span><br><span class="line">        <span class="keyword">const</span> parentElm = elm.<span class="property">parentNode</span> <span class="comment">// 获取父元素</span></span><br><span class="line">        <span class="keyword">let</span> newElm = <span class="title function_">createElm</span>(vnode) <span class="comment">// 获取新节点</span></span><br><span class="line">        parentElm.<span class="title function_">insertBefore</span>(newElm, elm.<span class="property">nextSibling</span>) <span class="comment">// 插入新节点</span></span><br><span class="line">        parentElm.<span class="title function_">removeChild</span>(elm) <span class="comment">// 删除老节点</span></span><br><span class="line">        <span class="keyword">return</span> newElm</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 更新流程</span></span><br><span class="line">        <span class="comment">// Todo: diff算法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">patchProps</span>(<span class="params">el, props</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">        <span class="comment">// 处理样式</span></span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">&#x27;style&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> styleName <span class="keyword">in</span> props.<span class="property">style</span>) &#123;</span><br><span class="line">                el.<span class="property">style</span>[styleName] = props.<span class="property">style</span>[styleName]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            el.<span class="title function_">setAttribute</span>(key, props[key])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Todo: 处理其他属性 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createElm</span>(<span class="params">vnode</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; tag, data, children, text &#125; = vnode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理标签</span></span><br><span class="line">        <span class="comment">// 将真实节点和虚拟节点对应起来，后续如果修改属性可以通过虚拟节点找到真实节点，然后完成更新</span></span><br><span class="line">        vnode.<span class="property">el</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(tag)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理属性</span></span><br><span class="line">        <span class="title function_">patchProps</span>(vnode.<span class="property">el</span>, data)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理子元素，递归创建子节点</span></span><br><span class="line">        children.<span class="title function_">forEach</span>(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">            vnode.<span class="property">el</span>.<span class="title function_">appendChild</span>(<span class="title function_">createElm</span>(child))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理文本</span></span><br><span class="line">        vnode.<span class="property">el</span> = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(text)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vnode.<span class="property">el</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p><a href="https://github.com/edwhpt/vue2-stage">https://github.com/edwhpt/vue2-stage</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
